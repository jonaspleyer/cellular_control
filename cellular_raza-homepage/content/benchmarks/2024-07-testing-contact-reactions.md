---
title: Accuracy Testing of Contact Reactions
date: 2024-07-23
math: true
---

`cellular_raza 0.1.12` [introduced](/internals/releases) the new simulation aspect of
[`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) which can couple the
intracellular reactions of individual cells.
Testing the individual Adams-Bashforth solver which is used in the contact reactions update function
[`reactions_contact_adams_bashforth_2nd`](/docs/cellular_raza_core/backend/chili/fn.reactions_contact_adams_bashforth_2nd.html)
is part of a different testing approach.
In contrast, these tests take a high-level view and aim to match known results for a complete system
onto results generated by `cellular_raza`.

## Two-Component Uncoupled System
### Theoretical Formulation
The first test ensures that a system of two components given by

$$\\begin{align}
    \dot{x}(t) &= f(x) = \alpha\\\\
    \dot{y}(t) &= g(y) = \alpha y \\left(1 - \\frac{y}{y_\\text{max}} \\right)
\\end{align}$$

is correctly solved and no unintended coupling is introduced.
These equations correspond to linear growth for $x(t)$ and the well-known logistic curve
[\[1\]](#References) in $y(t)$.
The analytical solutions to these equations are given by

$$\\begin{align}
    x(t) &= \alpha(t-t_0)\\\\
    y(t) &= y_\text{max}\left(1+ \frac{y_\text{max}-y_0}{y_0} e^{-\alpha(t-t_0)} \right)^{-1}.
\\end{align}$$

### Implementation in `cellular_raza`
To model them with `cellular_raza` we define a new agent type `ContactCell`.

```rust
use cellular_raza::building_blocks::*;
use cellular_raza::concepts::*;
use cellular_raza::core::{backend::chili::*, storage::*, time::*};

use serde::{Deserialize, Serialize};

#[derive(CellAgent, Clone, Debug, Deserialize, Serialize)]
struct ContactCell {
    intracellular: nalgebra::Vector2<f64>,
    alpha0: f64,
    upper_limit: f64,
    #[Position]
    mechanics: NewtonDamped1DF32,
}
```
Notice that the `mechanics: NewtonDamped1DF32` component only serves as the positional information
such that we can use the predefined
[`CartesianCuboid`](/docs/cellular_raza_building_blocks/struct.CartesianCuboid.html) as the simulation domain.
Furthermore, we implement the required concepts
[`Intracellular`](/docs/cellular_raza_concepts/trait.Intracellular.html),
[`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) as follows.

```rust
impl Intracellular<nalgebra::Vector2<f64>> for ContactCell {
    fn get_intracellular(&self) -> nalgebra::Vector2<f64> {
        self.intracellular
    }
    fn set_intracellular(&mut self, intracellular: nalgebra::Vector2<f64>) {
        self.intracellular = intracellular;
    }
}

impl ReactionsContact<nalgebra::Vector2<f64>, nalgebra::Vector1<f32>> for ContactCell {
    fn calculate_contact_increment(
        &self,
        own_intracellular: &nalgebra::Vector2<f64>,
        ext_intracellular: &nalgebra::Vector2<f64>,
        _own_pos: &nalgebra::Vector1<f32>,
        _ext_pos: &nalgebra::Vector1<f32>,
        _rinf: &(),
    ) -> Result<(nalgebra::Vector2<f64>, nalgebra::Vector2<f64>), CalcError> {
        let calculate_incr = |y: f64| -> f64 {
            self.alpha0 * y * (1.0 - y / self.upper_limit)
        };
        let own_dr = [self.alpha0, calculate_incr(own_intracellular[1])].into();
        let ext_dr = [self.alpha0, calculate_incr(ext_intracellular[1])].into();
        Ok((own_dr, ext_dr))
    }
    fn get_contact_information(&self) -> () {}
}
```

The [`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) trait requires
that agents interact with each other, meaning we have to at least insert 2 agents into the
simulation to obtain any effect.
Since we employ no restraints on the range of interaction by not using the values `_own_pos` or
`_ext_pos` in the `calculate_contact_increment` function, every cell will interact with each other.
This also results in an increased reaction speed when more than 2 cells are present, meaning our
variable $\alpha$ for the exact solution is actually dependent on the number of species.

$$\begin{equation}
    \alpha = (N_\text{agents}-1)\alpha_0
\end{equation}$$

We have named the variable of the individual agents accordingly.

### Solving the System
Now we are ready to solve our system with the
[`run_simulation!`](/docs/cellular_raza_core::backend::chili::run_simulation) macro.
To test various configurations, we write a function which takes in all needed parameters to solve the system.

```rust
fn run_cellular_raza(
    alpha0: f64,
    y0: [f64; 2],
    upper_limit: f64,
    n_agents: usize,
    t0: f64,
    dt: f64,
    save_interval: f64,
    t_max: f64,
) -> Result<Vec<(f64, Vec<[f64; 2]>)>, SimulationError> {
    // Define initial values
    let y0 = nalgebra::Vector2::from(y0);

    // Agents
    let agents = (0..n_agents).map(|_| ContactCell {
        alpha0,
        intracellular: y0,
        upper_limit,
        mechanics: NewtonDamped1DF32 {
            pos: [0.5].into(),
            vel: [0.0].into(),
            damping_constant: 0.0,
            mass: 0.0,
        },
    });

    // Specify simulation domain, time and only store results intermediately in memory
    let domain = CartesianCuboid::from_boundaries_and_n_voxels([0.0; 1], [1.0; 1], [1; 1])?;
    let time = FixedStepsize::from_partial_save_interval(t0, dt, t_max, save_interval)?;
    let storage = StorageBuilder::new().priority([StorageOption::Memory]);
    let settings = Settings {
        n_threads: 1.try_into().unwrap(),
        show_progressbar: false,
        storage,
        time,
    };

    // Run full simulation and return storager to access results
    let storager = run_simulation!(
        agents: agents,
        settings: settings,
        domain: domain,
        aspects: [ReactionsContact],
    )?;

    // Gather cellular_raza results
    Ok(storager
        .cells
        .load_all_elements()?
        .into_iter()
        .map(|(iteration, elements)| {
            (
                t0 + iteration as f64 * dt,
                elements
                    .into_iter()
                    .map(|(_, (cbox, _))| cbox.cell.get_intracellular().into())
                    .collect(),
            )
        })
        .collect())
}
```

### Comparing Results
In order to meaningfully compare numerical results, we need an estimate for the local and global
truncation error [\[2\]](#References) which is introduced by our numerical solver.
For a given ODE in the form of 

$$\begin{equation}
    \dot{y} = f(t, y)
\end{equation}$$

which can be solved by an algorithm $A$ in the form of

$$\begin{equation}
    y_n = y_{n-1} + \Delta t A(t_{n-1}, y_{n-1}, \Delta t, f)
\end{equation}$$

the local truncation error $\tau_n$ is given by

$$\begin{equation}
    \tau_n = y(t_n) - y(t_{n-1}) - \Delta t A(t_{n-1}, y_{n-1}, \Delta t, f)
\end{equation}$$

and is related to the global truncation error $e_n$ via

$$\begin{align}
    e_n &= y(t_n) - y_n\\\\
        &= y(t_n) - (y_0 + \Delta A(t_0, y_0, \Delta t, f) + \dots + \Delta t A(t_{n-1},y_{n-1},\Delta t, f).
\end{align}$$

Under the additional condition that $f$ is Lipschitz with Lipschitz-constant $L$, we can derive a
bound for the global error.

$$\begin{equation}
    |e_n| \leq \frac{\text{max}_j \tau_j}{\Delta t L}\left(e^{L(t-t_0)} + 1 \right)
\end{equation}$$

where $\tau_n$ is the local truncation error at time step $n$.
By finding an upper bound for it, we can further simplify this formula.
The local truncation error $\tau_n$ depends on the type of solver used.
In our case, we employ the Adams-Bashforth [\[3\]](#References) solver with 3rd order.
The executed function in the [chili](/itnernals/backend/chili) backend is
[`contact_reactions_adams_bashforth_3rd`](/docs/cellular_raza_core/backend/chili/fn.reactions_contact_adams_bashforth_3rd.html).
The local truncation error is bound

$$\begin{equation}
    |\tau_n| \leq \frac{3\Delta t^4}{8}\sup\limits_{t\in(t_n-2\Delta t,x_n+\Delta t)}|y^{(4)}(t)|
\end{equation}$$

where $y^{(4)}(t)$ is the fourth-order derivative of the analytical solution $y$.
We can calculate this value for both ODEs by differentiating equations $(3)$ and $(4)$.

$$\begin{align}
    x^{(n)}(t) &= 0\\\\
    y^{(n)}(t) &= n! y_\text{max} \alpha^n\left(\frac{y_\text{max}-y_0}{y_0}\right)^n
        \left(1+\frac{y_\text{max}-y_0}{y_0}e^{-\alpha(t-t_0)}\right)^{-(n+1)}\\\\
\end{align}$$

With this upper bound on the local truncation error we can construct a new function which tests
that this upper bound is fulfilled.
We begin by writing down a general formula for the nth drivative of the exact solution to the
logistic curve ODE problem as given above.

```rust
fn compare_results(
    production: f64,
    y0: [f64; 2],
    upper_limit: f64,
    n_agents: usize,
    t0: f64,
    dt: f64,
    save_interval: f64,
    t_max: f64,
) -> Result<(), SimulationError> {
    // Define exact solution
    let exact_solution_derivative = |t: f64, n_deriv: i32| -> nalgebra::Vector2<f64> {
        let linear_growth = if n_deriv == 0 {
            y0[0] + (n_agents - 1) as f64 * production * (t - t0)
        } else {
            0.0
        };
        let q = (upper_limit - y0[1]) / y0[1];
        let logistic_curve = (1..n_deriv).product::<i32>() as f64
            * upper_limit
            * q.powi(n_deriv)
            * (1.0 + q * (-production * (n_agents - 1) as f64 * (t - t0)).exp())
                .powi(-(n_deriv + 1));
        nalgebra::Vector2::from([linear_growth, logistic_curve])
    };
    // ...
```

In the next step we use the Lipschitz-constants $L_0=\alpha$ and $L_1=\alpha y_0$ together with the
fourth derivative bound to calculate the local and global truncation errors.

```rust
    // ...

    // Estimate upper bound on local and global truncation error
    let lipschitz_constant = nalgebra::vector![
        (n_agents - 1) as f64 * production,
        (n_agents - 1) as f64 * production * y0[1]
    ];
    let fourth_derivative_bound = |t: f64| -> nalgebra::Vector2<f64> {
        nalgebra::vector![
            // This should be zero but due to machine precision we need to insert something here.
            // Since we are doing multiple operations such as add, multiply etc. we need more than
            // the minimal amount of precision
            80.0 * f64::EPSILON,
            exact_solution_derivative((t - 2.0 * dt).min(t0), 4)[1]
        ]
    };

    // Calculate upper bound on local and global truncation error
    let local_truncation_error = |t: f64| -> nalgebra::Vector2<f64> {
        &fourth_derivative_bound(t) * (3f64 / 8.0 * dt.powi(4))
    };
    let global_truncation_error = |t: f64| -> nalgebra::Vector2<f64> {
        nalgebra::Vector2::from([
            ((lipschitz_constant[0] * t).exp() - 1.0) * local_truncation_error(t)[0]
                / dt
                / lipschitz_constant[0],
            ((lipschitz_constant[1] * t).exp() - 1.0) * local_truncation_error(t)[1]
                / dt
                / lipschitz_constant[1],
        ])
    };

    // ...
```
In the final step, we use the already defined function `` to generate results from `cellular_raza`
and compare them with the exact known results.
Their difference has to be within the margin of the calculated global truncation error $e$.

```rust
    // ...

    // Obtain solutions from cellular_raza
    let solutions_cr = run_cellular_raza(
        production,
        y0,
        upper_limit,
        n_agents,
        t0,
        dt,
        save_interval,
        t_max,
    )?;

    // Compare the results
    for (t, res_cr) in solutions_cr {
        let res_ex = exact_solution_derivative(t, 0);
        let e = global_truncation_error(t);
        for r in res_cr {
            let d0 = (r[0] - res_ex[0]).abs();
            let d1 = (r[1] - res_ex[1]).abs();
            assert!(d0 < e[0]);
            assert!(d1 < e[1]);
        }
    }
    Ok(())
}
```

Equipped with this function `compare_results`, we can now use it for a collection of configurations
to test the solver.

```rust
#[test]
fn test_config0() {
    // Simulation parameters
    let production = 0.2;
    let y0 = [1.0, 2.0];
    let upper_limit = 12.0;
    let t0 = 3.0;
    let dt = 0.21;
    let save_interval = 0.42;
    let t_max = 20.000001;
    let n_agents = 2;
    compare_results(
        production,
        y0,
        upper_limit,
        n_agents,
        t0,
        dt,
        save_interval,
        t_max,
    )
    .unwrap();
}
```

## References
[1]
P. F. Verhulst,
“Recherches mathématiques sur la loi d’accroissement de la population.”
Nouveaux mémoires de l’Académie Royale des Sciences et Belles-Lettres de Bruxelles,
vol. 18, pp. 14–54, 1845,
[Online]. Available: [http://eudml.org/doc/182533](http://eudml.org/doc/182533)

[2]
E. Süli and D. F. Mayers,
“An Introduction to Numerical Analysis.”
Cambridge University Press,
Aug. 28, 2003.
doi: [10.1017/cbo9780511801181](https://doi.org/10.1017/CBO9780511801181)

[3]
Bashforth, Francis and Adams, J. Couch
An attempt to test the theories of capillary action : by comparing the theoretical and measured
forms of drops of fluid.
Cambridge [Eng.]: [Cambridge University Press, 1883](https://search.worldcat.org/title/1040022820)

[4]
G. Fasshauer,
“Numerical Methods for Differential Equations/Computational Mathematics II,”
2007,
[Online]. Available: [http://www.math.iit.edu/~fass/478578_Chapter_2.pdf](http://www.math.iit.edu/~fass/478578_Chapter_2.pdf)

