use std::collections::HashMap;

use crate::errors::{BoundaryError, DecomposeError};

/// Provides an abstraction of the physical total simulation domain.
///
/// [cellular_raza](https://github.com/jonaspleyer/cellular_raza) uses domain-decomposition
/// algorithms to split up the computational workload over multiple physical regions.
/// That's why the domain itself is mostly responsible for being deconstructed
/// into smaller [SubDomains](SubDomain) which can then be used to numerically solve our system.
pub trait Domain<C, S, Ci = Vec<C>> {
    /// Subdomains can be identified by their unique [SubDomainIndex](Domain::SubDomainIndex).
    /// The backend uses this property to construct a mapping (graph) between subdomains.
    type SubDomainIndex;

    /// Similarly to the [SubDomainIndex](Domain::SubDomainIndex), voxels can be accessed by
    /// their unique index. The backend will use this information to construct a mapping
    /// (graph) between voxels inside their respective subdomains.
    type VoxelIndex;

    /// Retrieves all indices of subdomains.
    fn get_all_voxel_indices(&self) -> Vec<Self::VoxelIndex>;

    /// Deconstructs the [Domain] into its respective subdomains.
    ///
    /// In addition, we provide the initial cells for the simulation
    fn decompose(
        self,
        n_subdomains: core::num::NonZeroUsize,
        cells: Ci,
    ) -> Result<DecomposedDomain<Self::SubDomainIndex, S, C>, DecomposeError>
    where
        S: SubDomain;
}

/// Generated by the [decompose](Domain::decompose) method. The backend will know how to
/// deal with this type and crate a working simulation from it.
pub struct DecomposedDomain<I, S, C> {
    /// Number of spawned [SubDomains](SubDomain). This number is guaranteed to be
    /// smaller or equal to the number may be different to the one given to the
    /// [Domain::decompose] method.
    /// Such behaviour can result from not being able to construct as many subdomains as desired.
    /// Note that this function will attempt to construct more [SubDomains](SubDomain)
    /// than available CPUs if given a larger number.
    pub n_subdomains: usize,
    /// Vector containing properties of individual [SubDomains](SubDomain).
    /// Entries are [Domain::SubDomainIndex], [SubDomain], and a vector of cells.
    pub index_subdomain_cells: Vec<(I, S, Vec<C>)>,
    /// Encapsulates how the subdomains are linked to each other.
    /// Eg. two subdomains without any boundary will never appear in each others collection
    /// of neighbors.
    /// For the future, we might opt to change to an undirected graph rather than a hashmap.
    pub neighbor_map: HashMap<I, Vec<I>>,
    /// Initial seed of the simulation for random number generation.
    pub rng_seed: u64,
}

/// Subdomains are produced by decomposing a [Domain] into multiple physical regions.
pub trait SubDomain {
    /// Individual Voxels inside each subdomain can be accessed by this index.
    type VoxelIndex;

    /// Obtains the neighbor voxels of the specified voxel index. This function behaves similarly
    /// to [SubDomainSortCells::get_voxel_index_of] in that it also has to return
    /// indices which are in other [SubDomains](SubDomain).
    fn get_neighbor_voxel_indices(&self, voxel_index: &Self::VoxelIndex) -> Vec<Self::VoxelIndex>;

    // fn apply_boundary(&self, cell: &mut C) -> Result<(), BoundaryError>;

    /// Get all voxel indices of this [SubDomain].
    fn get_all_indices(&self) -> Vec<Self::VoxelIndex>;
}

/// TODO
pub trait SubDomainSortCells<C>: SubDomain {
    /// If given a cell, we can sort this cell into the corresponding Voxel.
    /// This function is supposed to return the correct voxel index of the cell
    /// even if this index is inside another [SubDomain].
    /// This restriction might be lifted in the future but is still
    /// required now.
    fn get_voxel_index_of(&self, cell: &C) -> Result<Self::VoxelIndex, BoundaryError>;
}

///
pub trait SubDomainMechanics<Pos, Vel> {
    /// If the subdomain has boundary conditions, this function will enforce them onto the cells.
    /// For the future, we plan to replace this function to additionally obtain information
    /// about the previous and current location of the cell.
    fn apply_boundary(&self, pos: &mut Pos, vel: &mut Vel) -> Result<(), BoundaryError>;
}

///
pub trait SubDomainForce<Pos, Vel, For> {
    ///
    fn calculate_custom_force(&self, pos: &Pos, vel: &Vel) -> Result<For, crate::CalcError>;
}

/// Specifies how to retrieve a unique identifier of an object.
pub trait Id {
    /// The identifier type is usually chosen to be completely unique and repeatable across
    /// different simulations.
    type Identifier;

    /// Retrieves the Identifier from the object.
    fn get_id(&self) -> Self::Identifier;
    /// Returns a reference to the id of the object.
    fn ref_id(&self) -> &Self::Identifier;
}

/// This trait derives the different aspects of a [SubDomain].
///
/// It serves similarly as the [cellular_raza_concepts_derive::CellAgent] trait to quickly
/// build new structures from already existing functionality.
///
/// | Attribute | Trait | Implemented |
/// | ---  | --- |:---:|
/// | `Base` | [SubDomain] | ✅ |
/// | `Mechanics` | [SubDomainMechanics] | ✅ |
/// | `SortCells` | [SubDomainSortCells] | ✅ |
/// | `Force` | [SubDomainForce] | ❌  |
/// | `Reactions` | [SubDomainReactions] | ❌ |
///
/// # Example Usage
/// ```
/// # use cellular_raza_concepts::domain_new::*;
/// # struct MySubDomain;
/// # impl SubDomain for MySubDomain {
/// #     type VoxelIndex = usize;
/// #     fn get_neighbor_voxel_indices(&self, voxel_index: &Self::VoxelIndex) -> Vec<usize> {
/// #         Vec::new()
/// #     }
/// #     fn get_all_indices(&self) -> Vec<Self::VoxelIndex> {
/// #         Vec::new()
/// #     }
/// # }
/// #[derive(SubDomain)]
/// struct MyDerivedSubDomain {
///     #[Base]
///     s: MySubDomain,
/// }
/// # let derived_subdomain = MyDerivedSubDomain {
/// #     s: MySubDomain,
/// # };
/// # let all_indices = derived_subdomain.get_all_indices();
/// # assert_eq!(all_indices.len(), 0);
/// ```
#[doc(inline)]
pub use cellular_raza_concepts_derive::SubDomain;
